<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/pikaqiu.ico?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="MIT lab的跟进记录防止划水开个坑记录一下">
<meta name="keywords" content="Kernel">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT lab记录">
<meta property="og:url" content="https://pwn.org.cn/2021/05/12/MITlab/index.html">
<meta property="og:site_name" content="Cooook&#39;s Blog">
<meta property="og:description" content="MIT lab的跟进记录防止划水开个坑记录一下">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-10-22T11:16:45.844Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT lab记录">
<meta name="twitter:description" content="MIT lab的跟进记录防止划水开个坑记录一下">
  <link rel="canonical" href="https://pwn.org.cn/2021/05/12/MITlab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>MIT lab记录 | Cooook's Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cooook's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">不管是怎样的回忆，都是我们活过的人生。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-links">
      
    

    <a href="/links/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>links</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://pwn.org.cn/2021/05/12/MITlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cooook">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/10/03/67Hi83ZnSBGKkRf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cooook's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">MIT lab记录

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-05-12 14:38:59" itemprop="dateCreated datePublished" datetime="2021-05-12T14:38:59+08:00">2021-05-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-22 19:16:45" itemprop="dateModified" datetime="2022-10-22T19:16:45+08:00">2022-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>MIT lab的跟进记录<br>防止划水开个坑记录一下<br><a id="more"></a></p>
<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p><strong>从BIOS到启动</strong><br>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the “Starting SeaBIOS” message you see in the QEMU window comes from.</p>
<p>当 BIOS 运行时，它建立一个中断描述符表并初始化各种设备，如 VGA 显示器。这就是 QEMU 窗口中看到的“ Starting SeaBIOS”消息的来源。</p>
<p>After initializing the PCI bus and all the important devices the BIOS knows about, it searches for a bootable device such as a floppy, hard drive, or CD-ROM. Eventually, when it finds a bootable disk, the BIOS reads the boot loader from the disk and transfers control to it.</p>
<p>初始化 PCI 总线和 BIOS 所知道的所有重要设备之后，它将搜索可引导设备，如软盘、硬盘驱动器或 CD-ROM。最终，当它找到一个可引导磁盘时，BIOS 从磁盘读取引导加载程序并将控制权转移给它。</p>
<p>Floppy and hard disks for PCs are divided into 512 byte regions called sectors. A sector is the disk’s minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary. If the disk is bootable, the first sector is called the boot sector, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a jmp instruction to set the CS:IP to 0000:7c00, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.</p>
<p>个人电脑的软盘和硬盘被分成512字节的区域，称为扇区。扇区是磁盘的最小传输粒度: 每个读或写操作的大小必须是一个或多个扇区，并与扇区边界对齐。如果磁盘是可引导的，则第一个扇区称为引导扇区，因为这是引导加载程序代码所在的位置。当 BIOS 找到可引导的软盘或硬盘时，它将512字节的引导扇区加载到物理地址0x7c00到0x7dff 的内存中，然后使用 jmp 指令将 CS: IP 设置为0000:7 c00，将控制权传递给引导加载程序。就像 BIOS 加载地址一样，这些地址是相当随意的，但是它们是固定的，并且是为 pc 标准化的。</p>
<p>简单来说就是BIOS检索可引导的设备, 然后将磁盘中的加载程序读取到内存中并将控制权交给控制程序。</p>
<p><strong>Be able to answer the following questions:</strong></p>
<ul>
<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li>
<li>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</li>
<li>Where is the first instruction of the kernel?</li>
<li>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[f000:d190]    0xfd190:	ljmpl  $0x8,$0xfd198 这条指令跳转导致16位转到32位模式</span><br><span class="line">0x7d6b:	call   *0x10018 最后一条指令 movw   $0x1234,0x472 第一条指令</span><br><span class="line">0x10000c</span><br><span class="line">根据physical address 和 end来算出来的</span><br></pre></td></tr></table></figure>
<h2 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h2><p>启动时候从扇区读取512字节，然后加载到内存的0x7c00地址, 先运行了boot.S中的内容，在boot.S中调用了boot_main<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb中symbols-file obj/boot/main.o 来加载符号表</span><br><span class="line">在boot.asm中查看对应的地址然后下断点</span><br><span class="line">加载符号表之后可以查看ELFHDR</span><br><span class="line">p *((struct Elf *) 0x10000)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -x 查看所有headers 包括符号</span><br><span class="line">objdump -f 查看headers</span><br></pre></td></tr></table></figure>
<h2 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h2><p>有ebp直接每次ebp = *ebp回溯直到ebp为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> *ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ebp) &#123;</span><br><span class="line">		cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, </span><br><span class="line">				ebp, *(ebp + <span class="number">1</span>), *(ebp + <span class="number">2</span>), *(ebp + <span class="number">3</span>), *(ebp + <span class="number">4</span>), *(ebp + <span class="number">5</span>), *(ebp + <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">		ebp = (<span class="keyword">uint32_t</span>*)*ebp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>增加函数名、行号等, 提示中显示用stab和stabstr节来实现.<br>.stab 节：符号表部分，这一部分的功能是程序报错时可以提供错误信息。<br>.stabstr 节：符号表字符串部分。<br>这两个节在kernel.ld中链接进去，并且为符号提供了地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> __<span class="title">STAB_BEGIN__</span>[];</span>	<span class="comment">// Beginning of stabs table</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> __<span class="title">STAB_END__</span>[];</span>	<span class="comment">// End of stabs table</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> __STABSTR_BEGIN__[];		<span class="comment">// Beginning of string table</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span> __STABSTR_END__[];		<span class="comment">// End of string table</span></span><br></pre></td></tr></table></figure></p>
<p>.stab节信息的读取<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">objdump -G obj/kern/kernel</span><br><span class="line"></span><br><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)</span><br><span class="line">119    SLINE  0      24     00000000 0      </span><br><span class="line">120    SLINE  0      34     00000012 0      </span><br><span class="line">121    SLINE  0      36     00000017 0      </span><br><span class="line">122    SLINE  0      39     0000002b 0      </span><br><span class="line">123    SLINE  0      43     0000003a 0</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Symnum是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</li>
<li>n_type是符号类型，FUN指函数名，SLINE指在text段中的行号</li>
<li>n_othr目前没被使用，其值固定为0</li>
<li>n_desc表示在文件中的行号</li>
<li>n_value表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。<br>在kdebug.c中增加如下代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline)</span><br><span class="line">	info -&gt; eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>monitor.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> *ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ebp) &#123;</span><br><span class="line">		cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, </span><br><span class="line">				ebp, *(ebp + <span class="number">1</span>), *(ebp + <span class="number">2</span>), *(ebp + <span class="number">3</span>), *(ebp + <span class="number">4</span>), *(ebp + <span class="number">5</span>), *(ebp + <span class="number">6</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Eipdebuginfo));</span><br><span class="line">		result = debuginfo_eip(*(ebp + <span class="number">1</span>), &amp;info);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">			cprintf(<span class="string">"failed to get debuginfo for eip %x.\r\n"</span>, ebp[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cprintf(<span class="string">"\t%s:%d: %.*s+%u\r\n"</span>, </span><br><span class="line">				info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, *(ebp + <span class="number">1</span>) - info.eip_fn_addr);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ebp = (<span class="keyword">uint32_t</span>*)*ebp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>在JOS中, 0x00000000 -&gt; 0x000a0000被称作basemem<br>0x000a00000 -&gt; 0x00100000是IO hole<br>从0x00100000开始是extended mem</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><h3 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc"></a>boot_alloc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// This simple physical memory allocator is used only while JOS is setting</span><br><span class="line">// up its virtual memory system.  page_alloc() is the real allocator.</span><br><span class="line">//</span><br><span class="line">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &apos;n&apos;</span><br><span class="line">// bytes.  Doesn&apos;t initialize the memory.  Returns a kernel virtual address.</span><br><span class="line">//</span><br><span class="line">// If n==0, returns the address of the next free page without allocating</span><br><span class="line">// anything.</span><br><span class="line">//</span><br><span class="line">// If we&apos;re out of memory, boot_alloc should panic.</span><br><span class="line">// This function may ONLY be used during initialization,</span><br><span class="line">// before the page_free_list list has been set up.</span><br></pre></td></tr></table></figure>
<p>在boot_alloc中用到了end, end的定义在kernel.ld中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss : &#123;</span><br><span class="line">	PROVIDE(edata = .);</span><br><span class="line">	*(.bss)</span><br><span class="line">	PROVIDE(end = .);</span><br><span class="line">	BYTE(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>end为bss段最后一个地址<br>根据JOS的内存结构，从此处开始的内存为extended memory<br><strong>boot_alloc</strong>实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">boot_alloc(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">	<span class="keyword">char</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">	<span class="keyword">uint32_t</span> size;</span><br><span class="line">	<span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">	<span class="comment">// 'end' is a magic symbol automatically generated by the linker,</span></span><br><span class="line">	<span class="comment">// which points to the end of the kernel's bss segment:</span></span><br><span class="line">	<span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">	<span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE); 		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> nextfree; </span><br><span class="line">	<span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">	size = ROUNDUP(n, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (PGNUM(nextfree - end + size) &gt;= npages)</span><br><span class="line">		panic(<span class="string">"boot_alloc: No enough mem!\n"</span>);</span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree += size; </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init"></a>mem_init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Set up a two-level page table:</span><br><span class="line">//    kern_pgdir is its linear (virtual) address of the root</span><br><span class="line">//</span><br><span class="line">// This function only sets up the kernel part of the address space</span><br><span class="line">// (ie. addresses &gt;= UTOP).  The user part of the address space</span><br><span class="line">// will be set up later.</span><br><span class="line">//</span><br><span class="line">// From UTOP to ULIM, the user is allowed to read but not write.</span><br><span class="line">// Above ULIM the user cannot read or write.</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line">设置UVPT处为pgdir</span><br><span class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">pages = (struct PageInfo*) boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line">alloc npages个<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> 结构体来管理对应的内存页.</span></span><br></pre></td></tr></table></figure>
<h3 id="page-init"><a href="#page-init" class="headerlink" title="page_init"></a>page_init</h3><p>第一个页面是始终被占用的, IO hole是被占用的, 我们刚才申请的页面也不应该被放入到page_free_list中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">	<span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">	<span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">	<span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">	<span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></span><br><span class="line">	<span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">	<span class="comment">//     is free.</span></span><br><span class="line">	<span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">	<span class="comment">//     never be allocated.</span></span><br><span class="line">	<span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">	<span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">	<span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">	<span class="comment">//     page tables and other data structures?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Change the code to reflect this.</span></span><br><span class="line">	<span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">	<span class="comment">// free pages!</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">	pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	page_free_list = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span>* va = boot_alloc(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= npages_basemem &amp;&amp; page2kva(&amp;pages[i]) &lt; va) &#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">			pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">			pages[i].pp_link = page_free_list;</span><br><span class="line">			page_free_list = &amp;pages[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc"></a>page_alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with '\0' bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">victim</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">	page_free_list = victim -&gt; pp_link;</span><br><span class="line">	victim -&gt; pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(victim), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意memset的是对应的物理内存页.  </p>
<h3 id="page-free"><a href="#page-free" class="headerlink" title="page_free"></a>page_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">	<span class="keyword">if</span> (pp -&gt; pp_ref || pp -&gt; pp_link)</span><br><span class="line">		panic(<span class="string">"Error page_free: pp_ref of pp_link"</span>);</span><br><span class="line">	pp -&gt; pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><h3 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk"></a>pgdir_walk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	assert(pgdir); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">pde_t</span> *page_dir_entry = &amp;pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">pte_t</span> *pte = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span> ((*page_dir_entry &amp; PTE_P) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!create)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (pp == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		pp -&gt; pp_ref ++;</span><br><span class="line">		*page_dir_entry = page2pa(pp) | PTE_P | PTE_U | PTE_W; </span><br><span class="line">	&#125;</span><br><span class="line">	pte = KADDR(PTE_ADDR(pgdir[PDX(va)]));</span><br><span class="line">	<span class="keyword">return</span> &amp;pte[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region"></a>boot_map_region</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> *pte; </span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i += PGSIZE) &#123;</span><br><span class="line">		pte = pgdir_walk(pgdir, (<span class="keyword">char</span>*)(va + i), <span class="number">1</span>);</span><br><span class="line">		*pte = (pa + i) | perm | PTE_P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert"></a>page_insert</h3><p>pp -&gt; pp_ref需要先加然后再page_remove, 这样就不会因为pp_ref被减为0然后原来va处的page被删除<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	pp -&gt; pp_ref ++; </span><br><span class="line">	<span class="keyword">if</span> (*pte &amp; PTE_P) &#123;</span><br><span class="line">		tlb_invalidate(pgdir, va);</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pte = page2pa(pp) | perm | PTE_P; </span><br><span class="line">	<span class="comment">// pgdir[PDX(va)] = (pde_t)pte; </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup"></a>page_lookup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span> || ((*pte &amp; PTE_P) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	*pte_store = pte; </span><br><span class="line">	<span class="keyword">return</span> pa2page(*pte); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove"></a>page_remove</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">pte_t</span> *pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span> </span><br><span class="line">	pp = page_lookup(pgdir, va, &amp;pte);</span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	tlb_invalidate(pgdir, va); </span><br><span class="line">	*pte = <span class="number">0</span>; </span><br><span class="line">	page_decref(pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, ROUNDDOWN((<span class="number">1l</span>l &lt;&lt; <span class="number">32</span>) - KERNBASE, PGSIZE), <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>lab2 的buddy系统没有加</p>
<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><p>对gcc高版本的ld会出现问题<br>需要更改kernel.ld<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.bss : &#123;</span><br><span class="line">	PROVIDE(edata = .);</span><br><span class="line">	*(.bss)</span><br><span class="line">	*(COMMON)</span><br><span class="line">	PROVIDE(end = .);</span><br><span class="line">	BYTE(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>出现kva:00000000的原因是因为ld提供的end只是bss段的, 而pmap.o中的kern_pgdir并没有被算作bss段, 而且kern_pgdir的地址是在end之后的, 在memset的时候被清空了, 所以才会出现kva:00000000的问题.<br>修改后就可正常运行了.  </p>
<h2 id="Exercise-1-1"><a href="#Exercise-1-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><h3 id="mem-init-1"><a href="#mem-init-1" class="headerlink" title="mem_init"></a>mem_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">envs = (struct Env*) boot_alloc(<span class="keyword">sizeof</span>(struct Env) * NENV);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Env) * NENV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<h2 id="Exercise-2-1"><a href="#Exercise-2-1" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><h3 id="env-init"><a href="#env-init" class="headerlink" title="env_init"></a>env_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm"></a>env_setup_vm</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we've set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line">	e -&gt; env_pgdir = page2kva(p);</span><br><span class="line">	p -&gt; pp_ref ++ ;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PDX(UTOP); ++i)</span><br><span class="line">		e -&gt; env_pgdir[i] = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = PDX(UTOP); i &lt; NPDENTRIES; ++i)</span><br><span class="line">		e -&gt; env_pgdir[i] = kern_pgdir[i]; </span><br><span class="line">	<span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处将kern_pgdir里UTOP之上的所有页都映射到了user的地址空间中，在这里如果将NPEDENTRIES则在下面lcr3(PADDR(e -&gt; env_pgdir))之后会发生错误, 但是感觉现在内核中不是这样映射的  </p>
<h3 id="region-alloc"><a href="#region-alloc" class="headerlink" title="region_alloc"></a>region_alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *start, *end; </span><br><span class="line">	end = ROUNDUP(va + len, PGSIZE);</span><br><span class="line">	start = ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (; start &lt; end; start += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(pp = page_alloc(<span class="number">0</span>)))</span><br><span class="line">			panic(<span class="string">"No enough memory!"</span>);</span><br><span class="line">		<span class="keyword">if</span> (page_insert(e -&gt; env_pgdir, pp, start, PTE_U | PTE_W))</span><br><span class="line">			panic(<span class="string">"No enough memory!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a>load_icode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">	<span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program's entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span>* <span class="title">elf_header</span> = (<span class="title">struct</span> <span class="title">Elf</span>*)<span class="title">binary</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (elf_header -&gt; e_magic != ELF_MAGIC)</span><br><span class="line">		panic(<span class="string">"Not elf format"</span>);</span><br><span class="line">	</span><br><span class="line">	e -&gt; env_tf.tf_eip = elf_header -&gt; e_entry;</span><br><span class="line">	cprintf(<span class="string">"===== eip address: %p =====\n"</span>, elf_header -&gt; e_entry);</span><br><span class="line">	<span class="comment">// panic("I want to know eip address!");</span></span><br><span class="line">	</span><br><span class="line">	lcr3(PADDR(e -&gt; env_pgdir));</span><br><span class="line">	</span><br><span class="line">	ph = (struct Proghdr*)((<span class="keyword">uint8_t</span>*)elf_header + elf_header -&gt; e_phoff);</span><br><span class="line">	</span><br><span class="line">	eph = ph + elf_header -&gt; e_phnum;</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ++ph) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ph -&gt; p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (ph -&gt; p_filesz &gt; ph -&gt; p_memsz)</span><br><span class="line">				panic(<span class="string">"filesz &gt; memsz!"</span>);</span><br><span class="line"></span><br><span class="line">			region_alloc(e, (<span class="keyword">void</span>*)ph -&gt; p_va, ph -&gt; p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>((<span class="keyword">void</span>*)ph -&gt; p_va, (<span class="keyword">void</span>*)binary + ph -&gt; p_offset, ph -&gt; p_filesz);</span><br><span class="line">			<span class="built_in">memset</span>((<span class="keyword">void</span>*)ph -&gt; p_va + ph -&gt; p_filesz, <span class="number">0</span>, ph -&gt; p_memsz - ph -&gt; p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	region_alloc(e, (<span class="keyword">void</span>*)USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里ph -&gt; p_va已经对应到用户进程里的页表了, lcr3()使用user的页表.  </p>
<h3 id="env-create"><a href="#env-create" class="headerlink" title="env_create"></a>env_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">if</span> ((error = env_alloc(&amp;e, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"%e\n"</span>, error);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	load_icode(e, binary);</span><br><span class="line">	e -&gt; env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env-run"><a href="#env-run" class="headerlink" title="env_run"></a>env_run</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line">	<span class="comment">//	   1. Set the current environment (if any) back to</span></span><br><span class="line">	<span class="comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">	<span class="comment">//	      what other states it can be in),</span></span><br><span class="line">	<span class="comment">//	   2. Set 'curenv' to the new environment,</span></span><br><span class="line">	<span class="comment">//	   3. Set its status to ENV_RUNNING,</span></span><br><span class="line">	<span class="comment">//	   4. Update its 'env_runs' counter,</span></span><br><span class="line">	<span class="comment">//	   5. Use lcr3() to switch to its address space.</span></span><br><span class="line">	<span class="comment">// Step 2: Use env_pop_tf() to restore the environment's</span></span><br><span class="line">	<span class="comment">//	   registers and drop into user mode in the</span></span><br><span class="line">	<span class="comment">//	   environment.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hint: This function loads the new environment's state from</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">	<span class="comment">//	and make sure you have set the relevant parts of</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv &amp;&amp; curenv -&gt; env_status == ENV_RUNNING)</span><br><span class="line">		curenv -&gt; env_status = ENV_RUNNABLE;</span><br><span class="line">	curenv = e; </span><br><span class="line">	e -&gt; env_status = ENV_RUNNING;</span><br><span class="line">	e -&gt; env_runs ++; </span><br><span class="line">	lcr3(PADDR(e -&gt; env_pgdir));</span><br><span class="line">	env_pop_tf(&amp;e -&gt; env_tf);</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">"env_run not yet implemented"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h2><p>现代内核中 内核页表和用户空间页表有哪些项是相同的.<br>env_run中 curenv -&gt; env_status 还有可能是什么值?  </p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Kernel/" rel="tag"># Kernel</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2021/03/15/qemu/" rel="next" title="QEMU 初探">
                  <i class="fa fa-chevron-left"></i> QEMU 初探
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2022/07/13/ReverseCpp/" rel="prev" title="C++逆向与ghidra脚本">
                  C++逆向与ghidra脚本 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#lab1"><span class="nav-number">1.</span> <span class="nav-text">lab1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Boot-Loader"><span class="nav-number">1.1.</span> <span class="nav-text">Boot Loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#backtrace"><span class="nav-number">1.2.</span> <span class="nav-text">backtrace</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab2"><span class="nav-number">2.</span> <span class="nav-text">lab2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-1"><span class="nav-number">2.1.</span> <span class="nav-text">Exercise 1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#boot-alloc"><span class="nav-number">2.1.1.</span> <span class="nav-text">boot_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mem-init"><span class="nav-number">2.1.2.</span> <span class="nav-text">mem_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-init"><span class="nav-number">2.1.3.</span> <span class="nav-text">page_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-alloc"><span class="nav-number">2.1.4.</span> <span class="nav-text">page_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-free"><span class="nav-number">2.1.5.</span> <span class="nav-text">page_free</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-2"><span class="nav-number">2.2.</span> <span class="nav-text">Exercise 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pgdir-walk"><span class="nav-number">2.2.1.</span> <span class="nav-text">pgdir_walk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boot-map-region"><span class="nav-number">2.2.2.</span> <span class="nav-text">boot_map_region</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-insert"><span class="nav-number">2.2.3.</span> <span class="nav-text">page_insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-lookup"><span class="nav-number">2.2.4.</span> <span class="nav-text">page_lookup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-remove"><span class="nav-number">2.2.5.</span> <span class="nav-text">page_remove</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-5"><span class="nav-number">2.3.</span> <span class="nav-text">Exercise 5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO"><span class="nav-number">2.4.</span> <span class="nav-text">TODO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab3"><span class="nav-number">3.</span> <span class="nav-text">lab3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-1-1"><span class="nav-number">3.1.</span> <span class="nav-text">Exercise 1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mem-init-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">mem_init</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-2-1"><span class="nav-number">3.2.</span> <span class="nav-text">Exercise 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#env-init"><span class="nav-number">3.2.1.</span> <span class="nav-text">env_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-setup-vm"><span class="nav-number">3.2.2.</span> <span class="nav-text">env_setup_vm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#region-alloc"><span class="nav-number">3.2.3.</span> <span class="nav-text">region_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load-icode"><span class="nav-number">3.2.4.</span> <span class="nav-text">load_icode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-create"><span class="nav-number">3.2.5.</span> <span class="nav-text">env_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env-run"><span class="nav-number">3.2.6.</span> <span class="nav-text">env_run</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO-1"><span class="nav-number">3.3.</span> <span class="nav-text">TODO</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://i.loli.net/2019/10/03/67Hi83ZnSBGKkRf.jpg"
      alt="Cooook">
  <p class="site-author-name" itemprop="name">Cooook</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cooook</span>
</div>
  <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

  

</body>
</html>
